import{D as er,d}from"./index-B7GDeRPa.js";var or;let nr;function sr(t,r,e,o,u,ir){var E,c,O,z,D,B,S,cr=Symbol.metadata||Symbol.for("Symbol.metadata"),G=Object.defineProperty,K=Object.create,J=[K(null),K(null)],M=r.length;function _(n,h,w){return function(a,i){h&&(i=a,a=t);for(var p=0;p<n.length;p++)i=n[p].apply(a,w?[i]:[]);return w?i:a}}function I(n,h,w,a){if(typeof n!="function"&&(a||n!==void 0))throw new TypeError(h+" must "+(w||"be")+" a function"+(a?"":" or undefined"));return n}function Q(n,h,w,a,i,p,b,y,v,g,V){function L(l){if(!V(l))throw new TypeError("Attempted to access private element on non-instance")}var q=[].concat(h[0]),X=h[3],x=!b,$=i===1,Y=i===3,Z=i===4,C=i===2;function F(l,W,N){return function(A,rr){return W&&(rr=A,A=n),N&&N(A),s[l].call(A,rr)}}if(!x){var s={},R=[],m=Y?"get":Z||$?"set":"value";if(v?(g||$?s={get:tr(function(){return X(this)},a,"get"),set:function(l){h[4](this,l)}}:s[m]=X,g||tr(s[m],a,C?"":m)):g||(s=Object.getOwnPropertyDescriptor(n,a)),!g&&!v){if((c=J[+y][a])&&(c^i)!=7)throw Error("Decorating two elements with the same name ("+s[m].name+") is not supported yet");J[+y][a]=i<3?1:i}}for(var f=n,T=q.length-1;T>=0;T-=w?2:1){var H=I(q[T],"A decorator","be",!0),P=w?q[T-1]:void 0,k={},j={kind:["field","accessor","method","getter","setter","class"][i],name:a,metadata:E,addInitializer:(function(l,W){if(l.v)throw new TypeError("attempted to call addInitializer after decoration was finished");I(W,"An initializer","be",!0),p.push(W)}).bind(null,k)};if(x)c=H.call(P,f,j),k.v=1,I(c,"class decorators","return")&&(f=c);else if(j.static=y,j.private=v,c=j.access={has:v?V.bind():function(l){return a in l}},Z||(c.get=v?C?function(l){return L(l),s.value}:F("get",0,L):function(l){return l[a]}),C||Y||(c.set=v?F("set",0,L):function(l,W){l[a]=W}),f=H.call(P,$?{get:s.get,set:s.set}:s[m],j),k.v=1,$){if(typeof f=="object"&&f)(c=I(f.get,"accessor.get"))&&(s.get=c),(c=I(f.set,"accessor.set"))&&(s.set=c),(c=I(f.init,"accessor.init"))&&R.unshift(c);else if(f!==void 0)throw new TypeError("accessor decorators must return an object with get, set, or init properties or undefined")}else I(f,(g?"field":"method")+" decorators","return")&&(g?R.unshift(f):s[m]=f)}return i<2&&b.push(_(R,y,1),_(p,y,0)),g||x||(v?$?b.splice(-1,0,F("get",y),F("set",y)):b.push(C?s[m]:I.call.bind(s[m])):G(n,a,s)),f}function U(n){return G(n,cr,{configurable:!0,enumerable:!0,value:E})}return E=K(E??null),D=[],B=function(n){n&&D.push(_(n))},S=function(n,h){for(var w=0;w<e.length;w++){var a=e[w],i=a[1],p=7&i;if((8&i)==n&&!p==h){var b=a[2],y=!!a[3],v=16&i;Q(n?t:t.prototype,a,v,y?"#"+b:lr(b),p,p<2?[]:n?z=z||[]:O=O||[],D,!!n,y,h,n&&y?function(g){return dr(g)===t}:u)}}},S(8,0),S(0,0),S(8,1),S(0,1),B(O),B(z),c=D,M||U(t),{e:c,get c(){var n=[];return M&&[U(t=Q(t,[r],o,t.name,5,n)),_(n,1)]}}}function lr(t){var r=fr(t,"string");return typeof r=="symbol"?r:r+""}function fr(t,r){if(typeof t!="object"||!t)return t;var e=t[Symbol.toPrimitive];if(e!==void 0){var o=e.call(t,r);if(typeof o!="object")return o;throw new TypeError("@@toPrimitive must return a primitive value.")}return(r==="string"?String:Number)(t)}function tr(t,r,e){typeof r=="symbol"&&(r=(r=r.description)?"["+r+"]":"");try{Object.defineProperty(t,"name",{configurable:!0,value:e?e+" "+r:r})}catch{}return t}function dr(t){if(Object(t)!==t)throw TypeError("right-hand side of 'in' should be an object, got "+(t!==null?typeof t:"null"));return t}let ar;class ur{async createWorldInfo(r){try{return(await d.worldInfo.createWorldInfo({createWorldInfoRequestDto:r})).data}catch(e){throw console.error("Failed to create world info:",e),e}}async getWorldInfoList(r=1,e=10,o){try{const u={page:r,limit:e};return o&&(u.keyword=o),(await d.worldInfo.getWorldInfoList(u)).data}catch(u){throw console.error("Failed to get world info list:",u),u}}async getWorldInfoById(r){try{return(await d.worldInfo.getWorldInfoById({id:r})).data}catch(e){throw console.error(`Failed to get world info by id ${r}:`,e),e}}async updateWorldInfo(r,e){try{return(await d.worldInfo.updateWorldInfo({id:r,...e})).data}catch(o){throw console.error(`Failed to update world info ${r}:`,o),o}}async deleteWorldInfo(r){try{await d.worldInfo.deleteWorldInfo({id:r})}catch(e){throw console.error(`Failed to delete world info ${r}:`,e),e}}async associateWithCharacter(r,e){try{await d.worldInfo.associateWithCharacter({id:r,characterId:e})}catch(o){throw console.error(`Failed to associate world info ${r} with character ${e}:`,o),o}}async associateWithStory(r,e){try{await d.worldInfo.associateWithStory({id:r,storyId:e})}catch(o){throw console.error(`Failed to associate world info ${r} with story ${e}:`,o),o}}async createWorldInfoEntry(r,e){try{return(await d.worldInfo.createWorldInfoEntry({id:r,createWorldInfoEntryRequestDto:e})).data}catch(o){throw console.error(`Failed to create world info entry for world info ${r}:`,o),o}}async getWorldInfoEntries(r){try{return(await d.worldInfo.getWorldInfoEntries({id:r})).data}catch(e){throw console.error(`Failed to get entries for world info ${r}:`,e),e}}async updateWorldInfoEntry(r,e,o){try{return(await d.worldInfo.updateWorldInfoEntry({id:r,entryId:e},{data:o})).data}catch(u){throw console.error(`Failed to update entry ${e} for world info ${r}:`,u),u}}async deleteWorldInfoEntry(r,e){try{await d.worldInfo.deleteWorldInfoEntry({id:r,entryId:e})}catch(o){throw console.error(`Failed to delete entry ${e} for world info ${r}:`,o),o}}async testActivation(){try{await d.worldInfo.testActivation()}catch(r){throw console.error("Failed to test world info activation:",r),r}}}or=ur;[ar,nr]=sr(or,[er,er.Singleton],[],1).c;nr();const yr=new ar;export{yr as W};
